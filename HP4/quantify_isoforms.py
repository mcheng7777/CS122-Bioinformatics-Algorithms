import argparse
import zipfile
import numpy as np
from collections import defaultdict
from itertools import combinations


def parse_annotation_file(annotation_fn):
    """
    :param annotation_fn: the gene annotations file
    :return: outputs a list of tuples, "genes". Every tuple represents one gene, the first element of the tuple is the
            list of exon index ranges for that gene, the second element of the tuple is the list of isoforms that exist
            for that gene. For example, genes[0][0][0] references the first exon range of the first gene (in a tuple),
            genes[2][1][3] references the fourth isoform of the third gene.
    """

    with open(annotation_fn, 'r') as aFile:
        N = int(aFile.readline().strip())
        genes = [None]*N
        for i in range(N):
            numExons = int(aFile.readline().strip())
            exons = [None]*numExons
            starts = [int(x) for x in aFile.readline().strip().split(' ')]
            ends = [int(x) for x in aFile.readline().strip().split(' ')]
            for j in range(numExons):
                exons[j] = (starts[j], ends[j])
            numIsoforms = int(aFile.readline().strip())
            isoforms = [None]*numIsoforms
            for j in range(numIsoforms):
                isoforms[j] = [int(x) for x in aFile.readline().strip().split(' ')]
            genes[i] = (exons, isoforms)
    return genes


def parse_genome_file(genome_fn):
    """
    :param genome_fn: the full genome file
    :return: the string containing the genome
    """

    with open(genome_fn, 'r') as gFile:
        return gFile.readline().strip()


def parse_reads_file(reads_fn):
    """
    :param reads_fn: the file of shuffled reads
    :return: a list containing all of the shuffled reads
    """
    
    out_reads = []
    with open(reads_fn, 'r') as rFile:
        for line in rFile:
            out_reads.append(line.strip())
    return out_reads

def exome(genes,genome):
    edict = defaultdict(list)
    gcount=0
    for g in genes:
        exons = g[0]
        for e in exons:
            edict[gcount].append(genome[e[0]:e[1]+1])
        gcount+=1
    return edict

def mapreads(edict,reads):
    # initialize mapping hash table with each gene having a list of
    mapdict = defaultdict(list)
    for g in edict:
        mapdict[g] = [0]*len(edict[g])
    # map each read
    for r in reads:
        found = False
        while found==False: # continue search until read is mapped
            for g in edict: # look through all genes
                exons = edict[g]
                # look through all singular exons and exon pairs (accounts for junction-spanning reads)
                for singleexon in range(len(exons)):
                    if r in exons[singleexon]:
                        print("read mapped")
                        mapdict[g][singleexon]+=1
                        found = True
                        break
                else:
                    for e in list(combinations(range(len(edict[g])),2)):
                        if r in exons[e[0]]+exons[e[1]]:
                            print("read mapped")
                            mapdict[g][e[0]]+=1
                            mapdict[g][e[1]]+=1
                            found = True
                            break
                if found==True:
                    break
            # test if read was mapped to any of the exons
            if found==False:
                # print('read not mapped to exons')
                found=True
    return mapdict


def isoform_coverage(readlen, exons, isoforms, exoncounts, abundances):
    # make coefficent matrix
    # rows = exons, columns = isoforms
    mat = np.zeros((len(exoncounts),len(isoforms)),dtype=float)
    for i in range(len(isoforms)):
        for e in isoforms[i]:
            mat[e,i] = len(exons[e])/readlen
    cmat = np.zeros((len(exoncounts),1))
    for c in range(len(exoncounts)):
        cmat[c,0] = exoncounts[c]
    ls = list(np.linalg.lstsq(mat,exoncounts,rcond=None)[0])
    # abundances = []
    for i in range(len(isoforms)):
        isoseq = ""
        for num in isoforms[i]:
            isoseq = isoseq+exons[num]
        abundances.append((isoseq,ls[i]/sum(ls)))
    print("abundances calculated")
    return



def quantify_isoforms(genes, genome, reads):
    """
    :param genes: the list of gene tuples generated by the parser
    :param genome_fn: the full genome file
    :param reads_fn: the file of shuffled reads
    :return: a list of tuples, where the first element of the tuple is the transcript sequence (the isoform in terms of
            the exon sequences that form it in the genome), and the second element of the tuple is the abundance of that
            specific isoform

            NOTE: this skeleton is built assuming the return value exists like this, but as long as you change the way
            the output file is generated, this can be in whatever form you like.
    """

    """
        TODO: Within this function, you should go through most of the process of quantifying isoforms given the data.
            This can be broken down into the following few steps:
        
            1. Align reads to the genome, exome, or isoforms
                    your choice of method, but note the length of the genome
            
            2. Use the generated alignment to get exon counts
            
            3. Formulate your RNA seq problem using the isoforms and exon counts (linear algebra)
            
            4. Compute the isoform abundances based on your above formulation
    """
    # put in quantify_isoforms function
    edict = exome(genes, genome)
    mapdict = mapreads(edict, reads)
    abundances = []
    for g in mapdict:
        isoforms = genes[g][1]
        exons = edict[g]
        exoncounts = mapdict[g]
        readlen = 50
        isoform_coverage(readlen,exons,isoforms,exoncounts,abundances)
    return abundances


if __name__ == "__main__":
    """
    For an example of how you might call this script to run on the data provided:
    
    Usage: python proj4.py -g full_genome.txt -r shuffled_reads.txt -a DATA_PA_1100_0 -o test.out -t hw4_r_4_chr_1
    """
    parser = argparse.ArgumentParser(description='For now this starter code helps parse the files given, but leaves\n'
                                                 'the actual function that must be implemented empty')
    parser.add_argument('-g', '--genome', required=True, dest='genome_file', help='File containing the full genome')
    parser.add_argument('-r', '--reads', required=True, dest='read_file', help='File containing the shuffled reads')
    parser.add_argument('-a', '--annotation', required=True, dest='annotation_file', help='File containing gene '
                                                                                          'annotations')
    parser.add_argument('-o', '--outputFile', required=True, dest='output_file', help='Output file name')
    parser.add_argument('-t', '--outputHeader', required=True, dest='output_header',
                        help='String that needs to be output on the first line of the output file so that the online\n'
                             'submission system recognizes which leaderboard this file should be submitted to. For\n'
                             'hw4, this will be hw4_r_4_chr_1')

    args = parser.parse_args()
    genome_fn = args.genome_file
    reads_fn = args.read_file
    annotation_fn = args.annotation_file
    output_fn = args.output_file

    # genome_fn = "hw4_r_4/full_genome.txt"
    # reads_fn = "hw4_r_4/shuffled_reads.txt"
    # annotation_fn = "hw4_r_4/DATA_PA_1100_0.txt"

    genes = parse_annotation_file(annotation_fn)
    genome = parse_genome_file(genome_fn)
    reads = parse_reads_file(reads_fn)
    print(len(reads))

    output = quantify_isoforms(genes, genome, reads)
    with open(output_fn, 'w') as oFile:
        oFile.write('>' + args.output_header + '\n')
        oFile.write('>RNA\n')
        for isoform in output:
            out_str = '{} {}\n'.format(isoform[0], isoform[1])
            oFile.write(out_str)

    zip_fn = output_fn + '.zip'
    with zipfile.ZipFile(zip_fn, 'w') as zFile:
        zFile.write(output_fn)
